区分 就看  能不能被改变/赋值
不能，就是右值，只能在等号右边
可以，就是左值，也可以被赋值（当然也可以去把值赋给别人）

#引用的形式
1.左值引用
int& refval = value;
不能绑到立即数或字符等右值上，引用必须初始化

2.const 引用
const int& refval2 = value;           //refval2不可修改，是右值，放到左侧会报错
实际上是直接创建一个const 临时变量去绑定右值，可以绑char--->>string

3.右值引用（类似临时变量，主要是绑定到即将销毁的对象上，不保留）
int&& refval3 = 3;                     //绑定常量
refval3 = 5;                                //可以修改值

#解引用
int a = 9;
int * p = &a;
(* a) = 5;          //解引用，相当于a=5;
int& q = (* p); //  左值引用  绑定到左值  q=9

++i 和--i  是先加再用，不需要临时变量，相当于左值
i++和i--   是先用再加，需要临时变量，相当于右值
int i= 1;
int && r1 = i++;  //可以绑定，但是r1和i没有关系
int & r2 = ++i;     //可以绑定，而且r2绑定到i上
int &&r3 = ++i;   //不可以绑定，右值引用不能绑左值
int & r4 = i++;     //不可以绑定，左值引用不能绑右值

变量存在于地址中，是左值  立即数等primitive是固定，没有地址，是右值

&&相当于 转移对象，接收转移的指针直接可以用，不用重新new/delete

#stdmove 
std::move强制把左值转换成右值，可以理解做有立即数属性的变量
int && ra = 100;
int && rb = std::move (ra);
ra = 68;          //rb = 68;
rb=55;            //ra = 55;


#移动构造函数 
会把原内容清空
string st = "123123";
string str = std::move(st);
st变为空，str="123123"

#临时对象
1.代码运行时产生的
int && r1 = i++;             //i是先用再加，就相当于把原来的值给了r1不销毁了
2.代码书写问题产生的
a.函数形参 传进临时参数                       //可以直接引用
b.构造函数 默认参数产生的临时对象     //**同时还会动用拷贝赋值赋值，这个对象会被销毁**   *可以直接用值定义时初始化避免*
c.隐式转换  比如 char[] 被函数str形参调用时会自动调用string 的构造函数生成临时对象，==但是形参中要加const==
d.返回变量   *//可以删除参数不全的默认构造函数，都给上默认值，然后函数直接return计算结果，不创建临时变量和对象*

