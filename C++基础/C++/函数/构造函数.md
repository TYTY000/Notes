**构造函数末尾要加分号**
函数默认参数  写在函数声明的形参中
****一旦有默认值后，右方所有参数都必须给默认值****
 ####如果在有构造函数实现的情况下（可以调用）参数不够，编译系统会隐式地完成类型的转换
 可在函数声明前加上explicit，就只能显式声明了，少参数、赋值都会报错

#构造函数初始化列表
Time::Time(int tmphour , int tmpmin , int tmpsec)
							:Hour(tmphour),Minute(tmpmin),Second(tmpsec)
这和函数体内赋值不同，类似于变量初始化 和 变量赋值的区别一样。
**这里没有赋值号，只放在成员变量的括号中**

#常量成员函数
如 void function() const {}
不允许在函数体中修改成员变量的值
当然了，非成员函数也不能加const，因为都没有对象这个概念，不存在与类中
那么如果要在一个能接受常量变量的函数中修改成员变量应该怎么办呢？
*****使用mutable定义该成员变量，就能在常量成员函数中进行修改了*****

#指针符号
类似java，C++也有  * this，不过要注意有指针符号。
在编译器视角中
	Time& Time::rtnhour(Time * const this, int tmphour){}
	mytime.rtnhour(3)
	等价于
	mytime.rtnhour(&mytime,3);
###在成员函数体中，对类成员的直接访问都相当于this的隐式调用###
Minute........   //直接访问
或
this.Minute......      //隐式调用
this->Minute.......  //直接调用

#static
同Java，类的全局变量
可以通过  类名::成员函数名  调用
static 函数 只能操作 static 成员变量，两者都需要在源文件开头定义。
***在定义的时候就不用再加static了***
**可以通过类名调用，也可以通过对象名调用**

#类内初始值
**直接在成员变量定义中赋值**
在构造函数中赋值，初始化列表都会覆盖掉类内初始值

#const成员变量初始化
**只能使用初始化列表初始化**  构造函数内部是赋值！！！
因为这个时候变量还没有完成初始化

#默认构造函数  
当不存在构造函数时  编译器会自动构建，会确保对象的生成
但是如果写了构造函数，在创建对象时就要提供相应的实参才能成功创建。
但是默认的构造函数没有成员变量，没什么用
可以通过赋delete去禁用默认构造函数。
编译器认为
#构造函数默认值
不带参，直接赋default

#拷贝构造函数
**一般拷贝构造函数的第一个参数带const
单参函数一般声明为explicit 拷贝构造不声明
如果定义了拷贝构造函数，就需要在里边给成员逐个赋值