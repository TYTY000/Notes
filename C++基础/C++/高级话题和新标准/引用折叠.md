template <typename T>
void myfunc(T&& tmpv){   ....   }
如果此时传递进左值，编译器自动判断：T = int &, tmpv = int &;
如果此时传递进右值，编译器自动判断：T = int , tmpv = int &&;
那么，把左值的类型（实例化的T）传递进去后会变成：
void myfunc(int & &&tmpv) { ... }
在编译器的最终推断中，变成了：
void myfunc(int & tmpv){  ...  }
这就是引用折叠 reference-collapsing rules
因为此时&&tmpv 因为已经实例化过了，此处的&& tmpv只是右值引用，就被系统自动合并了。
具体实行 可以参考或。只有右值实例化传入右值形参引用，还是右值引用，其他折叠的效果都是左值引用。
**注意：此处说的折叠还是编译器类型判断，不是代码行内容**
即：在程序代码中，引用的引用是非法的，语法报错。编译器会自动处理模板中出现的引用的引用类的语法问题。