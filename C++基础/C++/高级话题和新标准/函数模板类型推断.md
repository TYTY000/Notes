为了理解函数模板类型推断到底是如何运行的，我们先要会查看类型推断结果，也就是编译器的类型推断结果。

引用形参：
1.如果实参是引用类型，引用部分会被忽略掉，T不会被推导为引用类型。（临时对象的传递？）
2.如果向引用类型的形参传入const类型实参的时候，形参就会成为const引用。（引用可修改，引用const不可修改）  首先要确保源数据的安全。
3.如果是指针：正常判断，形参匹配类型


常量引用形参：
所有类型的常量引用形参，模板类型都会被还原成源类型，（被常量引用形参吃掉）
T的类型不会被推导为引用类型，const也会被覆盖掉
指针：形参正常判断，类型匹配形参

万能引用：
编译器会自动判断万能引用的形参传递的实参是左值还是右值。


传值方式：
如果是按照临时对象传递，那么会创建一个新的临时对象，不是引用，也不是const
但是如果是按照指针传递，指针中涉及的  不能改变内容的const 会被保存，不能改变目标的const  会丢失（因为本质上是传递了临时对象，不能改变目标的属性消失了）
也就是说 ： 指针的常量性质 被忽略了，但是内容的常量性 会被保留

数组作为实参：
传入普通形参的不定长数组本身就是指针，同上。   模板类型和形参类型均为数组常量
但是引用类型形参，指的就是对象，会被限定尺寸。  模板类型为限定尺寸的数组常量，形参类型为引用 限定尺寸的数组常量。

#函数名作为实参
函数名代表了函数的首地址，也可以作为实参传入
编译器会判断 实参类型为相应类型的函数指针，形参类型匹配函数形参形式即可。
如：
void test( ){ }
template<typename T>
void myfunc (T tmpf){......}           //形参是函数指针
	myfunc(test);            //T = void(* )(void )           /tmpf = void (* ) (void)
template<typename T>
void myfunc (T& tmpf){......}          //形参是函数引用，相当于函数指针解引用了，形参形式要匹配。
	myfunc(test);            //T = void(void )           /tmpf = void (& ) (void)


总结：
1.编译器推断中，引用类型的实参的引用属性会被消除；
2.万能引用会被编译器只能识别，分别处理；
3.按值传递的实参，传递后对象的常量属性会被消除；
4.传递的指针会和形参类型进行匹配，符合语义；
5.函数引用会被当做对象处理，其他数组和函数会被看做指针。