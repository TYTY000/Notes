#POSIX-Safety-Concepts
Preliminary:
MT-Safe | AS-Safe | AC-Safe

Multi-Thread safe function
Asynchronous-Signal safe function
Asynchronous-Cancellous safe function

#Unsafe_Features
不安全的特征
**Lock**
Functions marked with lock as an AS-Unsafe feature may be interrupted by a signal while holding a non-recursive lock . If the signal handler calls another such function that takes the same lock , the result is a DEADLOCK.
Function annotated with lock as an AC-Unsafe feature may, if cancelled asynchronously, fail to release a lock that would have been released if their execution had not been interrupted by asynchronous thread cancellation. Once a lock is left taken, attempts to take that lock will block indefinitely.
*带锁的函数是异步信号敏感的，调用重复的锁的信号处理函数会导致死锁；带锁的函数也是异步取消敏感的，如果没有成功的释放锁，后续的线程都会被卡死*

**corrupt**
被corrupt标记的函数是异步信号敏感的，会损坏数据结构，被中断或其他函数中断会导致UB。**和带锁的函数不同，这些函数会使用递归的锁避免多线程安全问题。**
*数据损坏会被信号处理函数处理后进而导致进一步的损坏。*
同时也是异步取消敏感的，因为这些函数会留下损坏的、之部分更新的数据结构，后续使用这些数据结构会导致UB。

**heap**
标记了heap的函数会调用堆内存管理函数malloc/free族的函数，和他们一样安全，这个标记等同于AS-Unsafe lock | AC-Unsafe lock fd mem

**dlopen**
有这个标记的函数会用动态加载器把共享库加载进当前执行映像中；主要包括打开文件、文件内存映射、分配额外内存，解析符号、应用重分配等等，这些操作都需要持有内部的动态加载器锁。
这些锁对于AS-/AC-Unsage函数就够了，但是可能产生其它问题，目前这些问题就用dlopen这个占位符表示。

**plugin**
注释了plugin的函数可能调用libc外部的插件的代码。
这些插件函数默认都是多线程安全、异步信号和取消敏感；
尽管这些插件都是通过dlopen引入的，但是plugin关键字并不表示libdl接口和动态加载器有任何直接的关联，这些都是由dlopen覆盖的。
例如，如果一个函数加载一个模块，并且识别模块中一些函数的地址，如果还有其他函数调用了这些函数，第一个调用的就会带有dlopen标记，后续的就会带有plugin标记。如果只有一个函数调用，那么它就带有两个标记。

**i18n**
带有i18n标记的函数可能会调用国际化功能的函数，也只会拥有被调用函数的安全等级。（语言类？）
这个标记相当于多线程安全环境、异步信号敏感的数据损坏/堆或文件的调用、异步取消数据损坏。

**timer**
带有timer标记的函数会调用闹钟函数或类似于倒计时的系统调用，亦或是长时运行的操作。
在多线程程序中，可能存在倒计时结束信号被送给其他线程，导致没有中断所需线程的情况；
除了多线程不安全，这些函数也总是异步信号不安全的，因为在信号处理函数中调用这些函数总会和被中断代码中的计时器发生直接接触；同时也总是异步取消不安全的，**因为不能保证先前的计时器会在异步取消时被重置。**

#Conditionally_Safe_Features
条件性的安全特性
**init**
是多线程不安全的初始化。单线程需要单独跑一遍测试一下。
异步信号/取消不安全。使用的是libc_once或类似的机制去初始化内部数据结构。
如果信号处理程序中断了此类初始化函数，又调用了类似libc_once的初始化，在已加载libc线程库时就会死锁。
如果这个操作没有原子的完成，就会被多次执行，导致内存泄漏或内部数据损坏。
*需要调用init标记函数的、异步信号/取消不安全的应用程序，应该确保在使能取消、配置信号处理程序前就完成了初始化，确保与libc_once相关的异步信号/取消 安全问题不会产生。*

**race**
**如果记录中一个函数是通过传参/引用去读取/修改对象，程序员就应该确保使用内存同步原语去避免数据竞争，就不要调用库函数**
*FILE流是特例，因为POSIX要求库中函数避免在操作这种不确定类型对象时发生数据竞争。这只是给用户提供的一种方便，而不是一般需求。*
**保护实参数据安全是用户的责任。** 用户可以直接访问的数据、直接暴露给用户的数据，都不被libc库的race保护。
对于不确定类型的函数参数对象，用race后跟冒号、参数名注释的方式表明函数不为参数的同步负责。防止数据竞争是用户的事情。
**但这一点不适用于库控制的对象，比如库内部对象、用于返回特定函数调用的静态缓冲区。** 
对于用户可以直接访问的数据，可以用一个冒号和ID的标记区分，只要是有竞争的对象，采用临界区策略；持有互斥锁，但是这种方法不能在异步信号场合使用，仍然会UB。
对于静态缓冲区：互斥锁必须持有到调用函数结束为止，很多函数返回静态缓冲区的指针，提供可重入变量，将要返回的值直接存在调用提供的缓冲区里面。比如说tmpnames，传递一个存有指定值的缓冲区非空指针，而不是 一个任意的可重入入口点。通常都喜欢在多线程程序里这么写；只要没有其他内部缓冲区，就是多线程安全的；如果有（多线程不安全），技术文档就标注为race。

**const**
标有const的函数存在多线程的问题，会非原子的修改内部对象。这些对象最好被当做常量，因为GNU C库中很多的函数会在不同步的状态下访问它们。
**但和race不同，const问题只会存在于写者处。** 写者仍然是多线程、异步信号不安全的，但是强制的常量属性会让读者保持多线程和异步信号安全。因为常量对象不需要同步。
读者内部的const标记是作为一个安全提示出现的。
为了解决这个问题，可以使用一个非递归的、标记符绑定的读写锁，分别用一个读锁、写锁保护所有带有const标记的函数调用。和 race一样，这只是用一个非递归的锁解决多线程问题，会引发AS安全问题，在异步信号的场合会UB。

**sig**
标有sig的函数存在多线程问题，可能会临时设置一个信号处理，会影响冒号后标识信号的其他用法。
**只要确保函数调用期间不会有这个信号的其他用法，这个问题就解决了。**
*可以让要使用这个信号的所有函数争抢一个非递归互斥锁；或者是让这个信号在调用前堵塞，调用后恢复（推荐）*。
不能确保最初的信号处理函数在异步的环境下原封不动的恢复，**所以这个信号是AC_Unsafe的。** *在上述两种方法的同时，**建议同时禁用异步取消，并安装清理处理程序将信号恢复成所需状态后释放互斥锁***

**term**
标有term的函数存在多线程的问题，会采取默认方法修改终端设置。
比如：tcgetattr()，修改一些标记，然后tcsetattr()，这会产生一个其他线程丢失修改参数的窗口。
因此，term函数是多线程不安全的；**同样，这个窗口会导致异步信号的丢失，也是异步信号不安全的**，但是一般忽略后者标记。
所以建议使用终端的程序避免并行和可重入的交互，可采取不处理、堵塞会产生这些交互的信号，或者是使用互斥锁避免与终端的并行交互。这个锁同时也被用于race:tcattr(fd)的互斥。调用者可以简洁地用一个单独的互斥锁，或者是终端各自fd对应的互斥锁。
这些函数应该在临时变更参数后恢复成原状态，但是如果被取消，就会失败。因此为了避免异步取消问题，*上述方法的同时，**建议同时禁用异步取消，并安装清理处理程序将信号恢复原终端状态参数，再释放互斥锁*** 

#Other_Safety_Remark
额外的关键词必须与函数绑定，虽然不会导致函数不安全，但是也是一些特定类的函数需要考虑的特性：

**locale**
多线程安全的 从locale对象的读操作，不需要任何形式的同步操作。
并行的locale修改操作可能导致新老参数不可预测的混合执行。
我们不把这些函数标记为多线程异步信号不安全的，但是去修改locale的函数会被标记上const：locale并被视为不安全的；
*此外，异步信号不安全的term函数当存在多个同时运行或开启异步信号时  不允许被使用，因此locale可被视为高效的常量，进而使得多线程安全。*

**env**
多线程安全，访问环境变量，getenv()，不需要保护就可以确保并行修改的安全性。
**同样的：** 不把这些函数标记为MT/AS Unsafe；修改环境变量的函数都会有const：env标记，被视为不安全；因为AS-Unsafe，env var会被作为高效的常量，因此也能保证MT-Safe

**hostid**
MT safety，用于读取系统全局层面的机器HostID数据结构，因为HostID一般是不用改的，它通常不能被原子修改，gethostid()也被视为是安全的，但是修改的函数sethostid()通常会被标记上const：hostid，表明它被调用时需要给予特殊关照，此时通常需要从系统层面给予协调，而不是进程间的协调。

**sigintr**
MT-safety，可以安全地并行访问_sigintr内部数据结构，无需其他保护。
**同样的：** 不把这些函数标记为MT/AS Unsafe；修改环境变量的函数都会有const：sigintr标记，被视为不安全；因为AS-Unsafe，env var会被作为高效的常量，因此也能保证MT-Safe。

**fd**
AC-Safety 问题 ，执行时如果被异步线程取消可能泄露fd
分配、注销fd的函数会被标记.
分配、注销fd不能用一个单独的原子操作完成，因为总是会有一个窗口，fd还没有存到清理函数的参数中，或是在释放前就被取出来了，所以不能被释放。
为了防止fd泄露，可以用一些性能去交换，比如临时关闭异步线程取消。**但是，这个事需要调用分配/注销的函数自己去做，因为没有必要在高层去解决这个问题，造成更多的性能损失。** 此时fd注释并不会导致一个函数变成AC不安全的，只是说累加的fd泄露可能对一些程序造成影响，只需临时禁用异步取消就可以了。

**mem**
AC不安全问题，执行时如果被异步线程取消可能泄露mem
同fd类似，分配和注销内存的操作没有办法在一个原子操作中解决
mem注释并不会导致一个函数变成AC不安全的，只需在调用时临时禁用异步取消就可以了。

**cwd**
**多线程安全问题，可能在执行时临时改变当前工作目录，会导致相对路径在其他线程或异步信号/取消函数中解析变成UB。** 
这个问题不足以标记为MT/AS不安全，建议不用这个函数，直接用绝对路径、或者是fd相关的系统调用就可以了。

**!posix**
这个注释只是表示和posix标准中规定的状态不同，并没有说它不安全。例如：我们需要将一个函数变成安全的，但是posix标准中并没有这么要求。
但也不表示  没有这个注释就一定安全。

**:identifier**
注释是为了将函数进行分组，提供更加详细的信息，
通常，标识符用于命名一组函数，也可以命名一些全局对象和函数参数，或者是可识别属性或与会关联的逻辑组件，如:buf(arg)和:tcattr(fd)。
最常见的用法是标识出需要被相同同步原语保护的函数、参数逻辑组，确保在给定上下文中安全操作。

**/condition**
一些安全注释是带条件的，含参数、全局变量甚至是底层内核的bool表达式。
/hurd /!linux!bsd 表明只有在hurd内核  或是非linux/bsd的内核才能生效
/!ps和 /one_per_line表明只有当参数ps为NULL，或者全局变量 one_per_line为非零时才生效。

**当所有这些条件不成立、上述condition为否时，这个函数才能被认为是安全的**

#POSIX 
通常来说，POSIX标准中额外的要求和功能是为特定类型的操作系统环境提供底层支持，而不是提供不同操作系统平台下通用的编程语言支持。