#文件描述符
一个指向操作系统内对象的“指针”
只能通过操作系统允许的方式访问，从0开始编号（0,1,2）
可以通过open 取得， close 释放 ，dup 复制 
对于数据文件，fd 会保存上次访问文件的位置。
open：
O_CLOEXEC（fork()时会自动关掉这个fd，保证安全）
O_APPEND
write 和 offset 操作 被设计成类似原子操作，避免多次写导致的重复覆盖。**shared offset**  
dup：
dup ( int oldfd);
dup 会复制fd到一个最小的未占用fd，二者一体分享open连接，共享offset和文件状态标记，**但是不共享文件描述符标记，而且O_CLOEXEC标记是关闭的。**
dup 2 (int oldfd, int newfd);
dup2 可以指定new fd，如果这个fd之前是打开占用的，在重用前会静默关闭原来的文件，这个操作是原子的，因为不原子会导致竞争，因为在关闭和重用之间存在窗口。
如果old fd 不合法，那么dup2就会fail，也不会关闭new fd
如果old fd 合法，new fd = old fd ，什么都不做，返回new fd
dup3 (int oldfd, int newfd , int flags);
dup 3 又是dup 2的升级版： 调用者可以强制设定O_CLOEXEC标记，可以参考open里面的标记；
如果oldfd = newfd， dup3 fail return EINVAL

#man_fork
fork时，父子进程拥有相同的内存空间内容，之后就各自趋异。
子进程是父进程的拷贝，但在以下方面不同：
子进程拥有单独的PID，并且不与现有进程组或会话ID相对应；
子进程会更新父进程ID；
子进程不继承内存锁；
子进程的资源分配和CPU时间计数会被重置；
子进程的挂起信号队列为空；
子进程不继承信号量修改；
子进程不继承进程相关的记录锁，但是会继承fd open 锁 和flock
子进程不继承计时器；
子进程不继承未完成的异步IO操作和异步IO上下文。
NOTE：在linux系统下，fork()用写时复制的页实现，所以唯一的消耗就是复制父进程页表用去的时间和内存，以及创建子进程的task结构。

#Copy_On_Write
写时复制，不写的时候只复制页表，用页表的地址翻译让进程以为自己的内存空间是专有的（由MMU去执行映射操作），复制页表后相关的页更新引用计数，并且**抹除共享页的写权限；** 如果程序有写的权限并要修改内容，就会产生**page fault** ，操作系统检测到后再重新拷贝一份，减原页的引用计数，更新新页内容，并更新相应的页表项。
advantage：节约空间和时间，共享。
**统计进程占用的内存是个伪命题**

#Zygote_Process
效果：安卓应用秒起，是所有安卓应用的父进程/根，会完成所有安卓必要类的初始化和加载，如果要开，直接fork并设置ID和权限等内容，快速切入代码执行。即：一次加载，全员使用。
类似的有：
Chrome Site Isolation 
Fork Server 

#Sigaction 
\# include <signal.h>
int sigaction( int signum , const struct sigaction \*act, struct sigaction \*oldact );
系统调用sigaction()是为了改变进程收到一个特定信号要采取的动作。（man 7 signal）
不能改变SIGKILL 和 SIGSTOP，会安装非空的act 信号处理程序，把原来的动作保存到oldact中。

fork() + execve() + pipe = shell
一开始只有内存和文件描述符，但是后续又引入了线程、信号、进程间通信对象和ptrace跟踪调试（optional -f，follow所有子进程），所以后续的fork变得很复杂。
fork不能可靠的执行每个线程的复制，只有执行fork()的线程会被复制，线程的创建通过clone()。

#posix_spawn
更安全的创建一个子进程，是fork的上述漏洞的升级版。

#A_fork_in_the_road
Fork is no longer simple;有很多不同的标记和相关函数，很多小的库都必须文档说明fork行为，用户库随时都要准备fork等，都导致fork事实上并不简单。
Fork doesn't compose;如典型的缓冲IO，不会刷新缓冲区，导致重复输出。
Fork isn't thread-safe;只能拷贝调用fork的线程；除非序列化所有线程，子进程的地址空间内容和父进程的将不一致。容易死锁。
Fork is insecure;比如说：需要给显式给子进程消除无关的状态，比如关闭fd，删除敏感内容，用unshare()把命名空间隔离开等等。**从安全角度来看，默认从父进程继承的行为违背了最小特权的原则。** 更进一步的，fork但是不使用的程序会导致地址空间随机化失效。
Fork is slow;
![[Pasted image 20230127105120.png]]
MB正相关   和     常数时间
Fork isn't scale;  fork的写时复制机制会降低可扩展性，因为fork 的 API就有瓶颈，它无法与进程上其他的操作进行交互。很多其他因素也会制约fork的可扩展性，因为扩展的原则之一就是避免无用的共享：而fork就会把所有内容都共享，复制程序状态机的所有状态。因为fork出现的时候是单内核、算力不够发达的时代，fork鼓励中心化，复制和引用计数的操作开销很低。这就导致现代的内核很难同时处理安全性和可靠性。
Fork encourages memory overcommit.....因为怕fork超出内存限制直接被杀，fork都会保守的去实现，倾向于过度使用系统内存，判断内存容量是否能满足所有写时复制操作（程序数所需内存，一个fork就是2倍）；亦或是像Linux系统一样，依赖于虚拟内存，用dirty CoW的操作去保证每次fork都能够成功返回。

Fork现在是一个方便的API，用于单线程进程，内存占用小，内存布局简单，需要对其子进程的执行环境进行细粒度控制，但不需要与它们强隔离。==>  Shell

#实现fork中的难题
1.fork和单一地址空间不兼容。有的系统在一个用户地址空间中单独设计了虚拟进程，通过在地址空间的不同部分加载新的二进制文件和库，然后创建一个单独的线程来开始执行子进程，同时确保跨进程系统调用按预期执行。但是如果没有复杂的编译器和链接器修改，Fork在单个地址空间中是无法实现的。
2.fork和海量的硬件不兼容。实际上，fork将进程的定义限制在单个地址空间和在某个核心上运行的单个线程。操作系统不能复制网卡/GPU等硬件上的进程状态。随着未来的片上系统加入越来越多的有状态加速器，这种情况只会变得更糟。
3.fork影响整个系统。光是选择支持fork对系统的设计和运行时环境就有很大的限制。一个高效的fork要求在所有下层都实现fork。除非每一层都支持fork，否则它不能被使用。

#fork存在的问题
1.逆模块化。任何类型的对象实现(可能支持正在运行的进程)都需要在fork时定义其行为，而有些组件是长期后台运行的支持或优化组件，完全没有必要fork；
2.内在的懒惰需求。鉴于所有的核心资源，从内存区域到文件如fd 和 信号处理程序 ，都需要fork 的支持，并且为了提升糟糕的性能需要实现写时复制机制。**这不仅引入了单个对象的复杂性，并且也需要对象交互来保持fork出来的对象相互间的层级关系。** 
3.中心化。操作系统的扩展性来源于避免集中策略和避免使用精密全局信息的机制，因此状态和功能的分解就形成了核心理念。然而虽然fork在库代码中是自洽的，但它可能需要和进程原来通信的每个服务器和对象进行通信。
4.不容易扩展。除了违反我们核心的扩展原则之外，fork在某些系统中必须要么在父进程的内存中访问，要么把子进程放到系统的争用部分。

#替换fork
**1.高层的方法：spawn。**
posix_spawn() API可以简化这种重构，spawn的参数直接由额外定义的辅助函数指定。
缺点：一些不常用的操作如设置终端参数或切换到隔离的命名空间，都还不支持；同时也缺乏一些报错机制，在子进程开始执行之前，在子进程上下文中发生的失败(例如无效的文件描述符参数)将异步报告，并且与子进程的终止没有区别。
**2.可选的方法：vfork。**
为了让子进程访问父进程的栈，会把父进程的执行堵塞到exec。然而：由于共享地址空间，vfork的使用很难安全地使用。
*虽然vfork避免了复制地址空间的开销，而且有助于在spawn不实用的替换fork，但是一般情况下最好不要用。*
**3.底层：跨进程操作。** 
spawn类似的API要求在创建进程时，借助标记、参数和辅助函数，提供进程的所有参数。*不能让一个API能够完整的控制进程的初始状态。* 
**4.可选：clone。**
这个系统调用是linux所有进程和线程的创建的基础。虽然只需要单独的标志控制子进/线程状态，但是它也遭遇和fork一样的问题，对每个资源都要明确是在父子进/线程间共享还是拷贝一份。

#单独使用fork的场合 （不实用exec）
1.多进程服务器。虽然原来用并发服务器是为了复制进程用于处理并发请求，但现在随着技术的完善，这个理由已经不需要了。当大多数并发由线程处理时，fork创建的共享初始状态的性能优势就不那么重要了，而且现代操作系统会重复删除内存。最后，如果用fork，所有共享相同地址空间布局的进程容易遭到Blind ROP攻击。
（需要我们在无法获得二进制文件的情况下，通过 `ROP` 进行远程攻击，劫持该应用程序的控制流，可用于开启了 `ASLR`、`NX` 和栈 `canary` 的 `64-bit` `Linux`。）
2.写时复制的内存。现在用fork，更多的是为了利用写时复制的机制来减少复制内存的开销，来访问写时复制的内存，这些内存通常很快就会被丢弃；一个通用的场景就是将fork利用于预初始化进程中，减少应用启动开销和初始化进程占用的内存；一个典型的场景就是快照，捕获现有进程地址空间的一致快照，让父进程继续执行；一个典型的场景就是存档点，这可以极大减少软件安全隔离的开销。