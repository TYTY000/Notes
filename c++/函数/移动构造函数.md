#移动构造函数 
比拷贝更节省时间，不变内存直接改绑（指针）
拷贝构造函数：
Time::Time(const Time& tmptime){......}
此处的形参是左值引&。
移动构造函数中是右值引用&&，移动完成后原对象就不打算用了，就可以销毁，需要完成的任务：**1.完成资源的移动         2.源对象随时可销毁**
A( A&& tmpa) ==noexcept== : a(tmpa.a){      //用初始化的方式完成了移动
	tmpa.a=nullptr;     //a 是一个指向其他对象的指针，解绑可销毁
}            //移动构造函数
A a1(std::move(a));
**系统会自动识别构造函数的参数，是引用就是拷贝构造，是右值就是移动构造**
*A &&a2(std::move(a));只会将2个指针指向同一个地址（2个对象是同一个对象）*
*A &&a3 = a;临时绑定*        //也需要重写赋值运算符

**如果一个类自己定义了拷贝函数/析构函数/拷贝运算符，编译器就不会自动合成移动构造函数，需要手写
如果没手写移动构造函数/赋值符，就会自动使用拷贝函数/运算符
仅当这个类是primitive或有移动函数时，成员变量才可以移动。**

小结
1.大量new的内存的类   需要移动构造函数和移动赋值运算符
2.加noexcept关键词
3.加了移动构造函数记得虚函数析构
4.如果没有就用拷贝代替