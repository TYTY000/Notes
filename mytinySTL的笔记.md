感谢ALinShan。

1.既然是底层重构STL，
* 必须实现针对不同数据类型的内存地址分配和解分配，
* 针对不同的数据类型，利用其构造等一系列函数进行自动的批量生成，
* 先是由模板类allocator负责调用全局new和delete，然后由各个容器类针对各种构造析构函数进行具体的处置；
* 具体的，针对primitive type 和 用户自定义类型利用模板编程去区分对待，前者什么也不做，后者生成时调用其默认构造函数，摧毁时调用其析构函数。
* 生成  先分配内存然后再进行对象创建，自定义类型需要定义大小并且默认是要做形参包展开。
* （但是这个项目没有实现内存池，这个有空再去实现）

2.当然为了通用性还要实现不同类型的迭代器，
* 这个里边主要用到的技巧也是模板编程，继承一个空的带模板的结构体来确定数据的类型，
* 主要有输入输出、前向双向还有随机访问，主要是定义标签类型，这个类型会作为迭代器访问数据的默认参数放在调用接口的最后。
* 针对抽象迭代器的定义实现不同的访问方法，其次需要实现迭代器的运算符重载（如++、–、\*、->）以支持迭代器的各种操作；

3.需要针对顺序（vector）、分布（list）、局部顺序（堆）等不同类型进行不同的设置，
* 如可以为list类封装两层，一层是代表具体数据的<T>，一层是代表相互连接关系的node；

4.在实现了迭代器和容器的基本功能后，可进一步实现适配器（stack、queue）和算法 （sort/find/transform等）；

5.既然实现了算法，也就要实现函数，函数主要分为三类，一元、二元和多元（这个就要用到可变参数模板了），还有一些基础的转发、衰退类型的获取（类型萃取）等；

6.为了满足map和set，还要完成hash的设置，这里用的方法是？？？

7.具体的实现有序和无序map和set，有序map和set通常基于红黑树（red-black tree）实现，以保证元素的有序性。无序map和set则基于哈希表实现。需要注意的是，在插入和删除元素时，要维护整体的大小关系。

8.deque的实现有点雷伊一个简单的内存池，用块的iterator{_begin, _cur, _end}来遍历deque的连续块空间，微修改填充、删除的逻辑即可，需要注意要额外加上头尾的判断。
* 实际上，deque是一个有些类似页表的两层指针，一层指向分散的缓冲区，二层指向缓冲区中具体的元素，扩展也是默认2倍扩容
* 其次还需要做一些常见功能，比如说在前后保留多少个元素，不够就重新allocate，逻辑稍微复杂一些。

9.hashtable
针对是否键重复进行分别定义增删的方法，分别对应unique/multi。
    哈希表结构：
        使用二级链表结构，一级链表用于哈希快速查找，二级链表用于处理冲突。
        选择合适的哈希函数，确保哈希值均匀分布。

    不重复和重复元素的处理：
        对于 set，在插入元素时检查是否已经存在，若存在则不插入。
        对于 multiset，允许重复元素插入，但需要记录每个元素的出现次数。

    增删查逻辑：
        插入：计算哈希值，插入到对应的链表中。对于 set，需要先检查是否存在。
        删除：找到对应的链表节点并删除。对于 multiset，如果元素出现次数大于1，则减少计数，否则删除节点。
        查找：计算哈希值，遍历对应的链表查找元素。

    装载因子和重哈希：
        定义装载因子（如0.75），当哈希表的元素数量超过装载因子时，进行重哈希。
        重哈希时，创建一个更大的哈希表，重新计算所有元素的哈希值并插入新表中。
        
unordered multi？set即在hashtable的基础上调用其接口即可，是适配器。
unordered multi？map就是把键值和原值进行pair、first、second调整，还有at和下表操作，其他同unordered set几乎一样。

10.rb_tree

11.map/set