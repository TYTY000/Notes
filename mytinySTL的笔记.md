感谢ALinShan。

1.既然是底层重构STL，
* 必须实现针对不同数据类型的内存地址分配和解分配，
* 针对不同的数据类型，利用其构造等一系列函数进行自动的批量生成，
* 先是由模板类allocator负责调用全局new和delete，然后由各个容器类针对各种构造析构函数进行具体的处置；
* 具体的，针对primitive type 和 用户自定义类型利用模板编程去区分对待，前者什么也不做，后者生成时调用其默认构造函数，摧毁时调用其析构函数。
* 生成  先分配内存然后再进行对象创建，自定义类型需要定义大小并且默认是要做形参包展开。
* （但是这个项目没有实现内存池，这个有空再去实现）

2.当然为了通用性还要实现不同类型的迭代器，
* 这个里边主要用到的技巧也是模板编程，继承一个空的带模板的结构体来确定数据的类型，
* 主要有输入输出、前向双向还有随机访问，主要是定义标签类型，这个类型会作为迭代器访问数据的默认参数放在调用接口的最后。
* 针对抽象迭代器的定义实现不同的访问方法，其次需要实现迭代器的运算符重载（如++、–、\*、->）以支持迭代器的各种操作；

3.需要针对顺序（vector）、分布（list）、局部顺序（堆）等不同类型进行不同的设置，
* 如可以为list类封装两层，一层是代表具体数据的<T>，一层是代表相互连接关系的node；

4.在实现了迭代器和容器的基本功能后，可进一步实现适配器（stack、queue）和算法 （sort/find/transform等）；

5.既然实现了算法，也就要实现函数，函数主要分为三类，一元、二元和多元（这个就要用到可变参数模板了），还有一些基础的转发、衰退类型的获取（类型萃取）等；

6.为了满足map和set，还要完成hash的设置，这里用的方法是？？？

7.具体的实现有序和无序map和set，有序map和set通常基于红黑树（red-black tree）实现，以保证元素的有序性。无序map和set则基于哈希表实现。需要注意的是，在插入和删除元素时，要维护整体的大小关系。

8.deque的实现有点雷伊一个简单的内存池，用块的iterator{_begin, _cur, _end}来遍历deque的连续块空间，微修改填充、删除的逻辑即可，需要注意要额外加上头尾的判断。
* 实际上，deque是一个有些类似页表的两层指针，一层指向分散的缓冲区，二层指向缓冲区中具体的元素，扩展也是默认2倍扩容
* 其次还需要做一些常见功能，比如说在前后保留多少个元素，不够就重新allocate，逻辑稍微复杂一些。

9.hashtable
* 可以针对是否键重复进行分别定义增删的方法。
* 